/*******************************************************************************
 * Copyright 2012-2019 Phil Glover and contributors
 *  
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/

package org.pitest.pitclipse.runner;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toSet;
import static org.eclipse.core.runtime.FileLocator.getBundleFile;
import static org.hamcrest.CoreMatchers.hasItems;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.collection.IsEmptyCollection.empty;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.eclipse.core.runtime.Platform;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Before;
import org.junit.Test;
import org.pitest.mutationtest.MutationResultListenerFactory;
import org.pitest.mutationtest.engine.gregor.config.Mutator;
import org.pitest.pitclipse.core.Mutators;
import org.pitest.pitclipse.example.empty.EmptyClass;
import org.pitest.pitclipse.runner.results.ObjectFactory;
import org.pitest.pitclipse.runner.results.mutations.RecordingMutationsDispatcher;
import org.pitest.util.ServiceLoader;

/**
 * Tests the behavior of a {@link PitRunner}'s functions.
 */
// TODO Add more tests to ensure outputs generated by Pitest are OK
public class PitRunnerTest {

    /**
     * Where Eclipse and Maven will generate .class files
     */
    private static final String BUILD_OUTPUT_DIR = "target/classes";

    private static final List<String> PROJECTS = asList("project1", "project2");

    @Before
    public void clearMutations() {
        RecordingMutationsDispatcher.INSTANCE
            .dispatch(new ObjectFactory().createMutations());
    }

    @Test
    public void shouldRunPitest() throws IOException {
        PitRequest request = PitRequest.builder()
            .withPitOptions(
                options(
                    PitOptionsTest.class.getCanonicalName(),
                    asList("org.pitest.pitclipse.runner.*")))
            .withProjects(PROJECTS).build();
        PitResults results = new PitRunner().apply(request);
        assertThat(results, is(notNullValue()));
        assertThat(results.getHtmlResultFile(), is(aFileThatExists()));
        assertThat(results.getMutations(), is(notNullValue()));
        assertThat(results.getMutations().getMutation(), not(empty()));
        assertThat(results, is(serializable()));
    }

    @Test
    public void shouldRunPitestEvenWhenNoMutant() throws IOException {
        PitRequest request = PitRequest.builder()
            .withPitOptions(
                options(
                    EmptyClass.class.getCanonicalName(),
                    asList("org.pitest.pitclipse.example.empty.*")))
            .withProjects(PROJECTS).build();
        PitResults results = new PitRunner().apply(request);
        assertThat(results, is(notNullValue()));
        assertThat(results.getHtmlResultFile(), is(nullValue()));
        assertThat(results.getMutations(), is(notNullValue()));
        assertThat(results.getMutations().getMutation(), empty());
        assertThat(results, is(serializable()));
    }

    @Test 
    public void shouldFindAllAvailableMutationResultListeners() {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        Collection<MutationResultListenerFactory> factories = ServiceLoader.load(MutationResultListenerFactory.class, contextClassLoader);
        Set<String> factoriesName = factories.stream().map(f -> f.name()).collect(toSet());
        
        String[] expectedFactoriesName = new String[] {"HTML", "CSV", "XML", "PITCLIPSE_MUTATIONS", "PITCLIPSE_SUMMARY"};
        assertThat(factoriesName, hasItems(expectedFactoriesName));
    }

    private <T> Matcher<T> serializable() {
        return new TypeSafeMatcher<T>() {
            @Override
            protected boolean matchesSafely(T candidate) {
                try {
                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
                    new ObjectOutputStream(byteStream).writeObject(candidate);
                    new ObjectInputStream(new ByteArrayInputStream(byteStream.toByteArray())).readObject();
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            @Override
            public void describeTo(Description description) {
                description.appendText("is serializable");
            }
        };
    }

    private Matcher<File> aFileThatExists() {
        return new TypeSafeMatcher<File>() {
            @Override
            public void describeTo(Description description) {
                description.appendText("file exists");
            }

            @Override
            protected boolean matchesSafely(File file) {
                return null != file && file.exists();
            }
        };
    }

    private static PitOptions options(String classUnderTest, List<String> classesToMutate) throws IOException {
        File srcDir = new File(System.getProperty("user.dir") + File.separator + "src");
        return PitOptions.builder()
            .withSourceDirectory(srcDir)
            .withClassUnderTest(classUnderTest)
            .withClassesToMutate(classesToMutate)
            .withClassPath(classPathWithPitestAndJUnit())
                       .build();
    }
    
    private static List<String> classPathWithPitestAndJUnit() throws IOException {
        final String jarDir = "lib";
        return asList(
            // TODO [Refactor] Pitest's classpath should be managed by the org.pitest bundle
            getBundleFile(Platform.getBundle("org.pitest")).getCanonicalPath(),
            getBundleFile(Platform.getBundle("org.pitest.pitclipse.runner")).getCanonicalPath(),
            getBundleFile(Platform.getBundle("org.pitest.pitclipse.runner")).getCanonicalPath() + File.separator + BUILD_OUTPUT_DIR,
            getBundleFile(Platform.getBundle("org.pitest")).getCanonicalPath()
               + File.separator + jarDir + File.separator + "pitest.jar",
            getBundleFile(Platform.getBundle("org.pitest")).getCanonicalPath()
               + File.separator + jarDir + File.separator + "pitest-entry.jar",
            getBundleFile(Platform.getBundle("org.pitest")).getCanonicalPath()
               + File.separator + jarDir + File.separator + "pitest-command-line.jar",
            getBundleFile(Platform.getBundle("org.pitest")).getCanonicalPath()
               + File.separator + jarDir + File.separator + "pitest-html-report.jar",
            getBundleFile(Platform.getBundle("com.google.guava")).getCanonicalPath(),
            // Add .class files to mutate
            new File(BUILD_OUTPUT_DIR).getAbsolutePath(),
            // Add JUnit dependency
            new File("lib/junit.jar").getAbsolutePath()
        );
    }

    /**
     * This test case is in place to detect whether the supplied mutators from pit
     * changed and we need to change {@link Mutators}.
     */
    @Test
    public void testTheMutatorApiOfPit() {
        assertThat(getPitMutatorsAsString(), equalTo(getExpectedMutatorsAsString()));
    }

    private String getPitMutatorsAsString() {
        StringBuilder sb = new StringBuilder();
        for (String mutator : Mutator.allMutatorIds()) {
            sb.append(mutator).append(',');
        }
        return sb.toString();
    }

    private String getExpectedMutatorsAsString() {
        return "INVERT_NEGS,RETURN_VALS,INLINE_CONSTS,MATH,VOID_METHOD_CALLS," +
                "NEGATE_CONDITIONALS,CONDITIONALS_BOUNDARY,INCREMENTS," +
                "REMOVE_INCREMENTS,NON_VOID_METHOD_CALLS,CONSTRUCTOR_CALLS," +
                "REMOVE_CONDITIONALS_EQ_IF,REMOVE_CONDITIONALS_EQ_ELSE," +
                "REMOVE_CONDITIONALS_ORD_IF,REMOVE_CONDITIONALS_ORD_ELSE," +
                "REMOVE_CONDITIONALS,TRUE_RETURNS,FALSE_RETURNS," +
                "PRIMITIVE_RETURNS,EMPTY_RETURNS,NULL_RETURNS," +
                "RETURNS,EXPERIMENTAL_MEMBER_VARIABLE," +
                "EXPERIMENTAL_SWITCH,EXPERIMENTAL_ARGUMENT_PROPAGATION," +
                "EXPERIMENTAL_NAKED_RECEIVER,EXPERIMENTAL_BIG_INTEGER," +
                "AOR_1,AOR_2,AOR_3,AOR_4,ABS,AOD1,AOD2,CRCR1,CRCR2,CRCR3,CRCR4," +
                "CRCR5,CRCR6,OBBN1,OBBN2,OBBN3,ROR1,ROR2,ROR3,ROR4,ROR5,UOI1," +
                "UOI2,UOI3,UOI4,REMOVE_SWITCH,OLD_DEFAULTS,STRONGER,ALL,DEFAULTS," +
                "AOR,AOD,CRCR,OBBN,ROR,UOI,";
    }
}
